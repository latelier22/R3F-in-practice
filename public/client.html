<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Client ‚Äî Appel Robot (g√©oloc r√©elle)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root { --pad: 14px; }
    html, body { height: 100%; margin: 0; font-family: system-ui, sans-serif; }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header { padding: var(--pad); font-weight: 800; }
    #map { height: 55vh; }
    .panel { padding: var(--pad); display: grid; gap: 12px; }
    button {
      padding: 12px 16px; font-weight: 800; border-radius: 12px; cursor: pointer;
      border: 2px solid #c00; background: #ffefef; color: #900;
    }
    .meta { color: #555; font-size: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>üìç Client ‚Äî g√©olocalisation</header>
    <div id="map"></div>
    <div class="panel">
      <button id="btn-appel">üö® APPEL ROBOT</button>
      <div class="meta" id="status">En attente de g√©olocalisation‚Ä¶</div>
    </div>
  </div>

<script>
const WS_URL  = 'wss://sti2d.latelier22.fr/fiber-ws/';
const API_URL = 'https://sti2d.latelier22.fr/fiber/api/call-robot';

const statusEl = document.getElementById('status');
const btnAppel = document.getElementById('btn-appel');

const map = L.map('map', { zoomControl: true }).setView([48.185, -2.758], 16);
L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
  attribution: '¬© OSM France', maxZoom: 20
}).addTo(map);

let meMarker = null;
let meAccuracy = null;
let lastFix = null; // {x,y,acc,time}

// ---- WebSocket (pour envoyer l‚Äô√©v√®nement "appel")
let ws=null, retry=0, hb=null, idle=null;
function wsConnect(){
  if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
  ws = new WebSocket(WS_URL);
  ws.onopen = ()=>{
    retry = 0;
    try { ws.send(JSON.stringify({ type:'hello', client:'client-geoloc' })); } catch {}
    hb = setInterval(()=>{ try{ ws.send(JSON.stringify({type:'ping', t:Date.now()})) }catch{} }, 20000);
    resetIdle();
  };
  ws.onmessage = ()=> resetIdle();
  ws.onerror = (e)=> console.warn('WS error', e?.message||e);
  ws.onclose = ()=>{
    clearInterval(hb); hb=null; clearTimeout(idle); idle=null;
    const backoff = Math.min(10000, 500*Math.pow(2, retry++));
    setTimeout(wsConnect, backoff);
  };
  function resetIdle(){ clearTimeout(idle); idle = setTimeout(()=>{ try{ws.close()}catch{} }, 45000); }
}
wsConnect();

function wsSend(obj){ if(!ws || ws.readyState!==WebSocket.OPEN) return false; try{ ws.send(JSON.stringify(obj)); return true; }catch{ return false; } }

// ---- G√©olocalisation (one-shot au clic, mais on pr√©pare aussi un watch pour fluidit√©)
let watchId = null;
function startWatch(){
  if (watchId !== null) return;
  if (!('geolocation' in navigator)) {
    statusEl.textContent = 'G√©olocalisation non disponible sur cet appareil.';
    return;
  }
  watchId = navigator.geolocation.watchPosition(
    pos => {
      const { latitude, longitude, accuracy } = pos.coords;
      lastFix = { x: latitude, y: longitude, acc: accuracy, time: Date.now() };

      // Mise √† jour carte
      const ll = L.latLng(latitude, longitude);
      if (!meMarker) {
        meMarker = L.marker(ll).addTo(map);
        meAccuracy = L.circle(ll, { radius: accuracy, color: '#08f', fillColor: '#08f', fillOpacity: 0.15 }).addTo(map);
        map.setView(ll, 18);
      } else {
        meMarker.setLatLng(ll);
        meAccuracy.setLatLng(ll).setRadius(accuracy);
      }
      statusEl.textContent = `Fix: lat ${latitude.toFixed(6)}, lng ${longitude.toFixed(6)} (¬±${Math.round(accuracy)} m)`;
    },
    err => {
      statusEl.textContent = `Erreur g√©oloc: ${err.message}`;
    },
    { enableHighAccuracy:true, maximumAge:5000, timeout:12000 }
  );
}
startWatch(); // lance d√®s l‚Äôouverture (l‚Äôutilisateur autorisera au besoin)

// ---- Bouton APPEL
btnAppel.addEventListener('click', async () => {
  const ok = window.confirm(
    "‚ö†Ô∏è CECI EST UN APPEL D‚ÄôURGENCE.\n\n" +
    "Confirmez-vous l‚Äôenvoi de l‚ÄôAPPEL ROBOT depuis votre position actuelle ?"
  );
  if (!ok) return;

  // Si pas encore de fix, tente un one-shot
  if (!lastFix) {
    try {
      const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy:true, maximumAge:0, timeout:12000 }));
      const { latitude, longitude, accuracy } = pos.coords;
      lastFix = { x: latitude, y: longitude, acc: accuracy, time: Date.now() };
    } catch (e) {
      alert("Impossible d'obtenir votre position. Autorisez la g√©oloc ou r√©essayez.");
      return;
    }
  }

  // 1) √âv√®nement temps r√©el ‚Äî pour d√©clencher triggerAppel c√¥t√© r√©cepteur
  const sent = wsSend({ type:'appel', data:{ t: Date.now(), source:'client-geoloc' } });

  // 2) Envoi HTTP de la cible (target)
  const target = { x:lastFix.x, y:lastFix.y, time: Date.now(), meta:{ acc: lastFix.acc, source:'client-geoloc' } };
  try {
    const r  = await fetch(API_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(target) });
    const js = await r.json();
    console.log('üì§ call-robot OK:', js);
    statusEl.textContent = `Appel envoy√© @ ${new Date().toLocaleTimeString()}`;
    if (!sent) alert("Position envoy√©e (HTTP OK), mais la WebSocket n'√©tait pas connect√©e.");
  } catch (e) {
    console.error('‚ùå call-robot KO:', e);
    alert("√âchec de l'appel HTTP.");
  }
});
</script>
</body>
</html>
