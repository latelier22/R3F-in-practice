<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>KML: zoom & point al√©atoire dans "limites"</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .tools {
      position: fixed; right: 12px; top: 12px; z-index: 1000; display: grid; gap: 8px;
    }
    .btn {
      background: #fff; border: 1px solid #bbb; border-radius: 10px;
      padding: 10px 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,.15);
    }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .btn.alert { background: #ffefef; border-color: #c00; color: #900; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="tools">
    <button id="fit" class="btn">üó∫Ô∏è Zoom "limites"</button>
    <button id="rand" class="btn">üéØ Point al√©atoire dans "limites"</button>
    <button id="appel" class="btn alert" disabled>üö® APPEL ROBOT</button>
  </div>

<script>
const KML_URL = 'lycee.kml'; // <-- adapte si besoin
// (Optionnel) endpoints si tu veux envoyer l'appel
const WS_URL  = 'wss://sti2d.latelier22.fr/fiber-ws/';
const API_URL = 'https://sti2d.latelier22.fr/fiber/api/call-robot';

const map = L.map('map', { preferCanvas:true }).setView([48.185, -2.758], 18);
L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
  attribution: '¬© OSM France', maxZoom: 20
}).addTo(map);

let limitesPoly = null;        // turf.polygon (le vrai ‚Äúlimites‚Äù)
let limitesLayer = null;       // Layer Leaflet
let limitesBounds = null;      // L.LatLngBounds du polygone
let marker = null;             // Marker choisi
let chosen = null;             // { x:lat, y:lng, time }

const btnFit   = document.getElementById('fit');
const btnRand  = document.getElementById('rand');
const btnAppel = document.getElementById('appel');

// ---------------- Parse KML & trouver le Placemark name == "limites" ----------------
fetch(KML_URL).then(r => r.text()).then(kmlText => {
  const xml = new DOMParser().parseFromString(kmlText, "text/xml");
  const placemarks = [...xml.querySelectorAll('Placemark')];

  const limPm = placemarks.find(pm => {
    const name = pm.querySelector('name')?.textContent?.trim() || '';
    return name.toLowerCase() === 'limites';
  });

  if (!limPm) {
    alert('Aucun Placemark nomm√© "limites" dans le KML.');
    return;
  }

  // Support Polygon ou MultiGeometry>Polygon
  const polys = [...limPm.querySelectorAll('Polygon')];
  if (!polys.length) {
    alert('Le Placemark "limites" ne contient pas de <Polygon>.');
    return;
  }

  // On ne garde que l‚ÄôouterBoundary du 1er polygon (si plusieurs, on peut les fusionner ‚Äî ici on prend le premier)
  const ringNode = polys[0].querySelector('outerBoundaryIs > LinearRing > coordinates');
  if (!ringNode) {
    alert('Polygon "limites": pas de LinearRing outerBoundary.');
    return;
  }

  // KML: "lon,lat[,alt] lon,lat ..."
  const coordsLonLat = ringNode.textContent.trim().split(/\s+/).map(pair => {
    const [lon, lat] = pair.split(',').map(Number);
    return [lon, lat];
  });
  // fermer l‚Äôanneau si ce n‚Äôest pas d√©j√† le cas
  const f = coordsLonLat[0], l = coordsLonLat[coordsLonLat.length-1];
  if (!l || f[0] !== l[0] || f[1] !== l[1]) coordsLonLat.push([f[0], f[1]]);

  limitesPoly = turf.polygon([coordsLonLat]);

  // Dessin Leaflet (conversion en [lat,lng])
  const coordsLatLng = coordsLonLat.map(([lon, lat]) => [lat, lon]);
  limitesLayer = L.polygon(coordsLatLng, { color:'#0a7', weight:2, fillColor:'#0f7', fillOpacity:.15 }).addTo(map);

  // Bounds exactes du polygone
  limitesBounds = L.latLngBounds(coordsLatLng);
  map.fitBounds(limitesBounds, { padding:[30,30] });

  // Active les boutons
  btnFit.disabled = false;
  btnRand.disabled = false;
}).catch(err => {
  console.error('Erreur KML:', err);
  alert('Impossible de charger le KML (chemin ou CORS).');
});

// ---------------- Helpers ----------------
function randomPointInsidePoly(poly, bounds, maxTries = 4000) {
  // bounds: L.LatLngBounds
  const minX = bounds.getWest(),  minY = bounds.getSouth();
  const maxX = bounds.getEast(),  maxY = bounds.getNorth();

  for (let i = 0; i < maxTries; i++) {
    const lon = minX + Math.random() * (maxX - minX);
    const lat = minY + Math.random() * (maxY - minY);
    const pt = turf.point([lon, lat]); // turf = [lon,lat]
    if (turf.booleanPointInPolygon(pt, poly)) {
      return L.latLng(lat, lon);      // Leaflet = [lat,lon]
    }
  }
  return null;
}

// ---------------- UI ----------------
btnFit.onclick = () => {
  if (!limitesBounds) { alert('KML "limites" pas charg√©.'); return; }
  map.fitBounds(limitesBounds, { padding:[30,30] });
};

btnRand.onclick = () => {
  if (!limitesPoly || !limitesBounds) { alert('KML "limites" pas charg√©.'); return; }
  const ll = randomPointInsidePoly(limitesPoly, limitesBounds);
  if (!ll) { alert("Impossible de trouver un point √† l'int√©rieur. R√©essayez."); return; }

  if (marker) map.removeLayer(marker);
  marker = L.marker(ll).addTo(map);
  map.flyTo(ll, Math.max(18, map.getZoom()));

  chosen = { x: ll.lat, y: ll.lng, time: Date.now() };
  btnAppel.disabled = false; // on a une position ‚Üí on peut appeler
};

// ---------------- (Optionnel) Appel Robot: envoi de la position choisie ----------------
let ws = null, retry=0, hb=null, idle=null;
function wsConnect(){
  if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
  ws = new WebSocket(WS_URL);
  ws.onopen = ()=>{ retry=0; try{ ws.send(JSON.stringify({type:'hello',client:'carte-emettrice'})) }catch{}; hb=setInterval(()=>{try{ws.send(JSON.stringify({type:'ping',t:Date.now()}))}catch{}},20000); resetIdle(); };
  ws.onmessage = ()=> resetIdle();
  ws.onerror = e=> console.warn('WS error', e?.message||e);
  ws.onclose = ()=>{ clearInterval(hb); hb=null; clearTimeout(idle); idle=null; const backoff=Math.min(10000,500*Math.pow(2,retry++)); setTimeout(wsConnect, backoff); };
  function resetIdle(){ clearTimeout(idle); idle=setTimeout(()=>{ try{ws.close()}catch{} }, 45000); }
}
wsConnect();

function wsSend(obj){ if(!ws || ws.readyState!==WebSocket.OPEN) return false; try{ ws.send(JSON.stringify(obj)); return true; }catch{ return false; } }

btnAppel.onclick = () => {
  if (!chosen) { alert('Choisis d‚Äôabord une position al√©atoire.'); return; }

  const ok = window.confirm(
    "‚ö†Ô∏è CECI EST UN APPEL D‚ÄôURGENCE.\n\n" +
    "Confirmez-vous l‚Äôenvoi de l‚ÄôAPPEL ROBOT sur la position tir√©e dans \"limites\" ?"
  );
  if (!ok) return;

  // 1) WS ‚Äúappel‚Äù (pour que la Map2D d√©clenche triggerAppel c√¥t√© r√©cepteur)
  const sent = wsSend({ type: 'appel', data: { t: Date.now(), source: 'carte-emettrice' } });

  // 2) HTTP target (pour placer le robot c√¥t√© r√©cepteurs)
  fetch(API_URL, {
    method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(chosen)
  })
  .then(r => r.json())
  .then(js => {
    console.log('üì§ call-robot OK:', js);
    if (!sent) alert("Position envoy√©e (HTTP OK), mais la WebSocket n'√©tait pas connect√©e.");
  })
  .catch(err => {
    console.error('‚ùå call-robot KO:', err);
    alert('√âchec de l‚Äôappel HTTP (voir console).');
  });
};
</script>
</body>
</html>
