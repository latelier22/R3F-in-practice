<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>KML: zoom & point al√©atoire dans "limites"</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .tools {
      position: fixed; right: 12px; top: 12px; z-index: 1000; display: grid; gap: 8px;
    }
    .btn {
      background: #fff; border: 1px solid #bbb; border-radius: 10px;
      padding: 10px 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,.15);
    }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .btn.alert { background: #ffefef; border-color: #c00; color: #900; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="tools">
    <button id="fit" class="btn">üó∫Ô∏è Zoom "limites"</button>
    <button id="rand" class="btn">üéØ Point al√©atoire</button>
    <button id="appel" class="btn alert" disabled>üö® APPEL ROBOT</button>
  </div>

<script>
const KML_URL = 'lycee.kml';
const WS_URL  = 'wss://sti2d.latelier22.fr/fiber-ws/';
const API_URL = 'https://sti2d.latelier22.fr/fiber/api/call-robot';

let limitesPoly = null, limitesBounds = null;
let limitesLayer = null, marker = null, chosen = null;
let robotMarker = null;          // --- AJOUT
let robotTrail = null;           // --- AJOUT
let robotTrailCoords = [];       // --- AJOUT

const map = L.map('map', { preferCanvas:true }).setView([48.185, -2.758], 18);
L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
  attribution: '¬© OSM France', maxZoom: 20
}).addTo(map);

const btnFit   = document.getElementById('fit');
const btnRand  = document.getElementById('rand');
const btnAppel = document.getElementById('appel');

// ---------------- Parse KML & trouver le Placemark "limites" ----------------
fetch(KML_URL).then(r => r.text()).then(kmlText => {
  const xml = new DOMParser().parseFromString(kmlText, "text/xml");
  const limPm = [...xml.querySelectorAll('Placemark')].find(pm =>
    (pm.querySelector('name')?.textContent?.trim() || '').toLowerCase() === 'limites'
  );

  if (!limPm) return alert('Aucun Placemark "limites" dans le KML.');

  const ring = limPm.querySelector('Polygon > outerBoundaryIs > LinearRing > coordinates');
  if (!ring) return alert('Polygon "limites" sans <coordinates>.');

  const coordsLonLat = ring.textContent.trim().split(/\s+/).map(pair => {
    const [lon, lat] = pair.split(',').map(Number);
    return [lon, lat];
  });
  const f = coordsLonLat[0], l = coordsLonLat.at(-1);
  if (f[0] !== l[0] || f[1] !== l[1]) coordsLonLat.push([f[0], f[1]]);

  limitesPoly = turf.polygon([coordsLonLat]);
  const coordsLatLng = coordsLonLat.map(([lon, lat]) => [lat, lon]);
  limitesLayer = L.polygon(coordsLatLng, { color:'#0a7', weight:2, fillColor:'#0f7', fillOpacity:.15 }).addTo(map);
  limitesBounds = L.latLngBounds(coordsLatLng);
  map.fitBounds(limitesBounds, { padding:[30,30] });

  btnFit.disabled = false;
  btnRand.disabled = false;
  placeRandom();
});

function randomPointInsidePoly(poly, bounds, maxTries = 4000) {
  const minX = bounds.getWest(), minY = bounds.getSouth();
  const maxX = bounds.getEast(), maxY = bounds.getNorth();
  for (let i = 0; i < maxTries; i++) {
    const lon = minX + Math.random() * (maxX - minX);
    const lat = minY + Math.random() * (maxY - minY);
    const pt = turf.point([lon, lat]);
    if (turf.booleanPointInPolygon(pt, poly)) return L.latLng(lat, lon);
  }
  return null;
}

function placeRandom() {
  if (!limitesPoly || !limitesBounds) return;
  const ll = randomPointInsidePoly(limitesPoly, limitesBounds);
  if (!ll) return;
  if (marker) map.removeLayer(marker);
  marker = L.marker(ll).addTo(map);
  map.setView(ll, Math.max(18, map.getZoom()));
  chosen = { x: ll.lat, y: ll.lng, time: Date.now() };
  btnAppel.disabled = false;
}

btnFit.onclick  = () => limitesBounds && map.fitBounds(limitesBounds, { padding:[30,30] });
btnRand.onclick = () => { placeRandom(); if (marker) map.flyTo(marker.getLatLng(), Math.max(18, map.getZoom())); };

// ---------------- WebSocket ----------------
let ws = null, retry=0, hb=null, idle=null;
function wsConnect(){
  if (ws && (ws.readyState===WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;
  ws = new WebSocket(WS_URL);
  ws.onopen = ()=>{
    retry=0;
    try{ ws.send(JSON.stringify({type:'hello',client:'carte-emettrice'})); }catch{}
    hb=setInterval(()=>{try{ws.send(JSON.stringify({type:'ping',t:Date.now()}))}catch{}},20000);
    resetIdle();
  };
  ws.onmessage = (e)=>{
    resetIdle();
    try{
      const msg = JSON.parse(e.data);
      // --- AJOUT : suivi robot ---
      if (msg.type === 'robot' && msg.data) {
        const { x:lat, y:lon } = msg.data;
        if (typeof lat !== 'number' || typeof lon !== 'number') return;
        const ll = L.latLng(lat, lon);

        if (!robotMarker) {
          robotMarker = L.marker(ll, {
            icon: L.icon({
              iconUrl: "https://cdn-icons-png.flaticon.com/512/3448/3448594.png",
              iconSize: [32, 32], iconAnchor: [16, 16]
            })
          }).addTo(map);
          robotTrailCoords = [ll];
          robotTrail = L.polyline(robotTrailCoords, { color:'#f60', weight:3, opacity:0.8 }).addTo(map);
        } else {
          robotMarker.setLatLng(ll);
          robotTrailCoords.push(ll);
          robotTrail.setLatLngs(robotTrailCoords.slice(-800));
        }
      }
    }catch{}
  };
  ws.onerror = e=> console.warn('WS error', e?.message||e);
  ws.onclose = ()=>{
    clearInterval(hb); hb=null; clearTimeout(idle); idle=null;
    const backoff=Math.min(10000,500*Math.pow(2,retry++));
    setTimeout(wsConnect, backoff);
  };
  function resetIdle(){ clearTimeout(idle); idle=setTimeout(()=>{ try{ws.close()}catch{} }, 45000); }
}
wsConnect();

function wsSend(obj){ if(!ws || ws.readyState!==WebSocket.OPEN) return false; try{ ws.send(JSON.stringify(obj)); return true; }catch{ return false; } }

// ---------------- Bouton APPEL ----------------
btnAppel.onclick = () => {
  if (!chosen) return alert('Choisis d‚Äôabord une position al√©atoire.');

  const ok = window.confirm(
    "‚ö†Ô∏è CECI EST UN APPEL D‚ÄôURGENCE.\n\nConfirmez-vous l‚Äôenvoi de l‚ÄôAPPEL ROBOT sur la position tir√©e dans \"limites\" ?"
  );
  if (!ok) return;

  // 1) message WS
  const sent = wsSend({ type: 'appel', data: { t: Date.now(), source: 'carte-emettrice' } });

  // 2) position HTTP
  fetch(API_URL, {
    method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(chosen)
  })
  .then(r => r.json())
  .then(js => {
    console.log('üì§ call-robot OK:', js);
    if (!sent) alert("Position envoy√©e (HTTP OK), mais WS non connect√©e.");
  })
  .catch(err => {
    console.error('‚ùå call-robot KO:', err);
    alert('√âchec HTTP (voir console).');
  });
};
</script>
</body>
</html>
